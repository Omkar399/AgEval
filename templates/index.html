<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgEval - AI Agent Evaluation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        :root {
            --primary: #1a1a1a;
            --secondary: #666666;
            --tertiary: #999999;
            --background: #ffffff;
            --surface: #f8f9fa;
            --border: #e5e7eb;
            --accent: #3b82f6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --radius: 8px;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--background);
            color: var(--primary);
            line-height: 1.6;
            font-size: 14px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        /* Header */
        .header {
            border-bottom: 1px solid var(--border);
            background: var(--background);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 64px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent), #6366f1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 16px;
        }

        .logo-text {
            font-size: 20px;
            font-weight: 600;
            color: var(--primary);
        }

        /* Navigation */
        .nav {
            display: flex;
            gap: 4px;
        }

        .nav-item {
            padding: 8px 16px;
            border-radius: var(--radius);
            color: var(--secondary);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .nav-item:hover {
            background: var(--surface);
            color: var(--primary);
        }

        .nav-item.active {
            background: var(--accent);
            color: white;
        }

        /* Main Content */
        .main {
            padding: 32px 0;
        }

        .section {
            margin-bottom: 48px;
        }

        .section-header {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .section-subtitle {
            color: var(--secondary);
            font-size: 16px;
        }

        /* Cards */
        .card {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-lg);
        }

        .card-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary);
        }

        .card-body {
            padding: 24px;
        }

        /* Grid */
        .grid {
            display: grid;
            gap: 24px;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }

        .grid-4 {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        /* Metrics */
        .metric {
            text-align: center;
        }

        .metric-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .metric-label {
            color: var(--secondary);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Agent Cards */
        .agent-card {
            padding: 20px;
            border-radius: var(--radius);
            background: var(--background);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .agent-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent);
        }

        .agent-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .agent-name {
            font-weight: 600;
            font-size: 16px;
            color: var(--primary);
        }

        .agent-rank {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            background: var(--surface);
            color: var(--secondary);
        }

        .agent-rank.gold { background: #fef3cd; color: #d97706; }
        .agent-rank.silver { background: #f3f4f6; color: #6b7280; }
        .agent-rank.bronze { background: #fef2f2; color: #dc2626; }

        .agent-score {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .agent-score.excellent { color: var(--success); }
        .agent-score.good { color: var(--accent); }
        .agent-score.moderate { color: var(--warning); }
        .agent-score.poor { color: var(--danger); }

        .agent-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 13px;
            color: var(--secondary);
        }

        /* Evaluation Progress */
        .progress-container {
            background: var(--surface);
            border-radius: 6px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #6366f1);
            transition: width 0.3s ease;
            border-radius: 6px;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-badge.waiting { background: #f3f4f6; color: #6b7280; }
        .status-badge.running { background: #dbeafe; color: var(--accent); }
        .status-badge.complete { background: #d1fae5; color: var(--success); }
        .status-badge.error { background: #fee2e2; color: var(--danger); }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border-radius: var(--radius);
            font-weight: 500;
            text-decoration: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 20px;
        }

        .label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--primary);
            font-size: 13px;
        }

        .input, .select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .input:focus, .select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 24px;
        }

        .tab {
            padding: 12px 20px;
            color: var(--secondary);
            text-decoration: none;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            font-weight: 500;
        }

        .tab:hover {
            color: var(--primary);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--background);
            border-radius: 12px;
            max-width: 90vw;
            max-height: 90vh;
            width: 800px;
            overflow: auto;
            box-shadow: var(--shadow-lg);
        }

        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--secondary);
            padding: 4px;
        }

        .modal-body {
            padding: 24px;
        }

        /* Hard Thinking Journey Styles - Enhanced Professional */
        .thinking-journey {
            min-height: 400px;
            position: relative;
            overflow: visible;
            margin-top: 32px;
        }

        .journey-stage {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            margin-bottom: 32px;
            background: linear-gradient(135deg, var(--background) 0%, var(--surface) 100%);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .journey-stage.active {
            opacity: 1;
            transform: translateY(0);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
            border-color: var(--accent);
        }

        .journey-stage.completed {
            opacity: 0.92;
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .stage-header {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 28px 28px 0 28px;
            background: linear-gradient(90deg, transparent 0%, rgba(59, 130, 246, 0.02) 100%);
            position: relative;
        }

        .stage-header::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(180deg, var(--accent), #6366f1);
            border-radius: 0 2px 2px 0;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .journey-stage.active .stage-header::before {
            opacity: 1;
        }

        .stage-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: var(--surface);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: var(--secondary);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            border: 2px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .stage-icon::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent), #6366f1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .stage-icon.active {
            color: white;
            border-color: var(--accent);
            transform: scale(1.08) rotate(2deg);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
        }

        .stage-icon.active::before {
            opacity: 1;
        }

        .stage-icon.completed {
            background: var(--success);
            color: white;
            border-color: var(--success);
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);
        }

        .stage-content {
            flex: 1;
        }

        .stage-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 4px;
            letter-spacing: -0.02em;
        }

        .stage-description {
            color: var(--secondary);
            font-size: 14px;
            font-weight: 400;
            opacity: 0.9;
        }

        .stage-body {
            padding: 8px 28px 28px 28px;
        }

        .stage-progress {
            margin-left: auto;
            font-size: 12px;
            color: var(--tertiary);
            font-weight: 500;
        }

        .stage-progress.active {
            color: var(--accent);
        }

        .thinking-content {
            background: linear-gradient(135deg, var(--background) 0%, var(--surface) 100%);
            border-radius: 12px;
            padding: 24px;
            margin-top: 20px;
            border: 1px solid var(--border);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }

        .thinking-content::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(99, 102, 241, 0.02) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .thinking-content.active {
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.1);
            transform: translateY(-2px);
        }

        .thinking-content.active::before {
            opacity: 1;
        }

        .content-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .content-text {
            font-size: 14px;
            line-height: 1.6;
            color: var(--primary);
            white-space: pre-wrap;
        }

        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .strategy-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 16px;
            padding: 20px;
            background: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .strategy-card {
            padding: 16px;
            border-radius: 8px;
            border: 2px solid var(--border);
            background: var(--background);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .strategy-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent), #6366f1);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .strategy-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15);
        }

        .strategy-card.selected {
            border-color: var(--accent);
            color: white;
            transform: scale(1.02);
        }

        .strategy-card.selected::before {
            opacity: 1;
        }

        .strategy-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            position: relative;
            z-index: 1;
        }

        .strategy-desc {
            font-size: 11px;
            opacity: 0.8;
            position: relative;
            z-index: 1;
        }

        .model-thoughts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 24px;
        }

        .model-card {
            background: linear-gradient(135deg, var(--background) 0%, var(--surface) 100%);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid var(--border);
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 0;
            transform: translateY(20px) scale(0.98);
            position: relative;
            overflow: hidden;
        }

        .model-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .model-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .model-card.thinking {
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.15);
        }

        .model-card.thinking::before {
            opacity: 1;
            animation: shimmer 2s infinite;
        }

        .model-card.gpt { 
            border-left: 4px solid #10a37f;
            background: linear-gradient(135deg, rgba(16, 163, 127, 0.02) 0%, var(--background) 100%);
        }
        .model-card.claude { 
            border-left: 4px solid #ff7a00;
            background: linear-gradient(135deg, rgba(255, 122, 0, 0.02) 0%, var(--background) 100%);
        }
        .model-card.gemini { 
            border-left: 4px solid #4285f4;
            background: linear-gradient(135deg, rgba(66, 133, 244, 0.02) 0%, var(--background) 100%);
        }

        .model-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .model-avatar {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 11px;
            color: white;
        }

        .model-avatar.gpt { background: #10a37f; }
        .model-avatar.claude { background: #ff7a00; }
        .model-avatar.gemini { background: #4285f4; }

        .model-name {
            font-weight: 500;
            color: var(--primary);
            font-size: 14px;
        }

        .model-status {
            margin-left: auto;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .model-response {
            background: var(--surface);
            padding: 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
            color: var(--primary);
            border-left: 3px solid var(--border);
            margin-top: 12px;
            position: relative;
        }

        .model-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
        }

        .metric-label {
            color: var(--secondary);
            font-weight: 500;
        }

        .metric-value {
            color: var(--primary);
            font-weight: 600;
        }

        .analysis-depth {
            background: linear-gradient(135deg, var(--surface) 0%, var(--background) 100%);
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
            border: 1px solid var(--border);
        }

        .analysis-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .analysis-content {
            font-size: 13px;
            line-height: 1.5;
            color: var(--secondary);
        }

        .strategy-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .strategy-result {
            background: var(--surface);
            border-radius: 10px;
            padding: 16px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .strategy-result.best {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05) 0%, var(--surface) 100%);
        }

        .strategy-name {
            font-weight: 600;
            font-size: 13px;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .strategy-score {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .strategy-details {
            font-size: 11px;
            color: var(--secondary);
            line-height: 1.4;
        }

        /* Sub-task Analysis Styles */
        .sub-task-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .sub-task-card {
            background: linear-gradient(135deg, var(--background) 0%, var(--surface) 100%);
            border-radius: 12px;
            padding: 18px;
            border: 1px solid var(--border);
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }

        .sub-task-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent), #6366f1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sub-task-card.active::before {
            opacity: 1;
        }

        .sub-task-card.completed {
            border-color: var(--success);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05) 0%, var(--surface) 100%);
        }

        .sub-task-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .sub-task-category {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: var(--accent);
            color: white;
        }

        .sub-task-status {
            margin-left: auto;
            font-size: 16px;
        }

        .sub-task-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .sub-task-analysis {
            font-size: 12px;
            color: var(--secondary);
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .sub-task-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .sub-task-metric {
            text-align: center;
            padding: 6px;
            background: var(--surface);
            border-radius: 6px;
        }

        .sub-task-metric-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent);
        }

        .sub-task-metric-label {
            font-size: 9px;
            color: var(--tertiary);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Winner Announcement */
        .winner-announcement {
            background: linear-gradient(135deg, #fdf2e9 0%, #fef3cd 100%);
            border: 2px solid #fbbf24;
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .winner-announcement::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        .winner-title {
            font-size: 20px;
            font-weight: 700;
            color: #d97706;
            margin-bottom: 8px;
        }

        .winner-model {
            font-size: 24px;
            font-weight: 800;
            color: #b45309;
            margin-bottom: 12px;
        }

        .winner-score {
            font-size: 16px;
            color: #92400e;
        }

        /* User Question Answer Styles */
        .user-question-answer {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .user-question-answer::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(14, 165, 233, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        .user-answer-text {
            font-size: 16px;
            line-height: 1.7;
            color: #0c4a6e;
            font-weight: 500;
            position: relative;
            z-index: 1;
            background: rgba(255, 255, 255, 0.8);
            padding: 16px;
            border-radius: 8px;
            margin-top: 12px;
            border-left: 4px solid #0ea5e9;
        }

        .final-answer-container {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-top: 16px;
        }

        .answer-text {
            font-size: 15px;
            line-height: 1.6;
            color: var(--primary);
            font-weight: 400;
        }

        .answer-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            font-size: 13px;
            color: var(--secondary);
        }

        .confidence-meter {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            padding: 16px;
            background: var(--surface);
            border-radius: 8px;
        }

        .confidence-bar {
            flex: 1;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--warning), var(--success));
            border-radius: 4px;
            transition: width 1s ease;
        }

        .progress-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 20px 0;
            padding: 0 24px;
        }

        .progress-step {
            flex: 1;
            height: 2px;
            background: var(--border);
            border-radius: 1px;
            transition: all 0.4s ease;
        }

        .progress-step.completed {
            background: var(--success);
        }

        .progress-step.active {
            background: var(--accent);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes thoughtAppear {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes modelCardAppear {
            0% {
                opacity: 0;
                transform: scale(0.95) translateY(20px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes pulseGlow {
            0%, 100% { 
                box-shadow: 0 4px 16px rgba(59, 130, 246, 0.15);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 8px 24px rgba(59, 130, 246, 0.25);
                transform: scale(1.02);
            }
        }

        @keyframes typewriter {
            from { width: 0; }
            to { width: 100%; }
        }

        .thinking-animation {
            animation: pulseGlow 2s infinite;
        }

        .typewriter-effect {
            overflow: hidden;
            white-space: nowrap;
            animation: typewriter 2s steps(40, end);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }

            .header-content {
                height: 56px;
            }

            .main {
                padding: 24px 0;
            }

            .section {
                margin-bottom: 32px;
            }

            .grid-2,
            .grid-3,
            .grid-4 {
                grid-template-columns: 1fr;
            }

            .card-body {
                padding: 20px;
            }
        }

        /* Hide elements */
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">A</div>
                    <div class="logo-text">AgEval</div>
                </div>
                <nav class="nav">
                    <a href="#overview" class="nav-item active" data-tab="overview">Overview</a>
                    <a href="#evaluation" class="nav-item" data-tab="evaluation">Evaluation</a>
                    <a href="#agents" class="nav-item" data-tab="agents">Agents</a>
                    <a href="#hardthinking" class="nav-item" data-tab="hardthinking">Hard Thinking</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <!-- Overview Tab -->
            <div id="overview" class="tab-content active">
                <div class="section">
                    <div class="section-header">
                        <h1 class="section-title">AI Agent Evaluation Dashboard</h1>
                        <p class="section-subtitle">Adaptive testing framework with real-time IRT analysis</p>
                    </div>

                    <div class="grid grid-4">
                        <div class="card">
                            <div class="card-body">
                                <div class="metric">
                                    <div class="metric-value" id="totalEvaluations">0</div>
                                    <div class="metric-label">Total Evaluations</div>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-body">
                                <div class="metric">
                                    <div class="metric-value" id="avgTasksPerAgent">0</div>
                                    <div class="metric-label">Avg Tasks/Agent</div>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-body">
                                <div class="metric">
                                    <div class="metric-value" id="convergenceRate">0%</div>
                                    <div class="metric-label">Convergence Rate</div>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-body">
                                <div class="metric">
                                    <div class="metric-value" id="efficiencyGain">0%</div>
                                    <div class="metric-label">Efficiency Gain</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Performance Comparison</div>
                        </div>
                        <div class="card-body">
                            <div id="comparisonPlot" style="height: 400px;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Evaluation Tab -->
            <div id="evaluation" class="tab-content">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Real-time Evaluation</h2>
                        <p class="section-subtitle">Run adaptive evaluations and monitor progress in real-time</p>
                    </div>

                    <div class="grid grid-2">
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">Control Panel</div>
                            </div>
                            <div class="card-body">
                                <div class="form-group">
                                    <label class="label">Evaluation Type</label>
                                    <select class="select" id="evaluationType">
                                        <option value="adaptive">Adaptive Evaluation</option>
                                        <option value="static">Static Evaluation</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="label">Number of Agents</label>
                                    <input type="number" class="input" id="numAgents" value="5" min="1" max="20">
                                </div>
                                <div style="display: flex; gap: 12px;">
                                    <button class="btn btn-primary" id="runEvaluation">
                                        <span>▶</span> Run Evaluation
                                    </button>
                                    <button class="btn btn-secondary" id="refreshData">
                                        <span>↻</span> Refresh
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="card" id="progressCard" style="display: none;">
                            <div class="card-header">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div class="card-title">
                                        <span id="evaluationIcon">⏳</span> Evaluation Progress
                                    </div>
                                    <div class="status-badge" id="stageIndicator">Waiting</div>
                                </div>
                            </div>
                            <div class="card-body">
                                <div class="progress-container">
                                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                                </div>
                                <div style="margin-bottom: 16px;">
                                    <div style="font-weight: 600; margin-bottom: 4px;" id="currentStage">Waiting to start...</div>
                                    <div style="color: var(--secondary); font-size: 13px;" id="currentSubstage">Ready to begin evaluation</div>
                                </div>

                                <div class="grid grid-4" id="realtimeMetrics" style="display: none;">
                                    <div class="metric">
                                        <div class="metric-value" id="tasksCompleted">0</div>
                                        <div class="metric-label">Tasks</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-value" id="currentAbility">0.000</div>
                                        <div class="metric-label">Ability θ</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-value" id="currentUncertainty">±0.000</div>
                                        <div class="metric-label">Uncertainty</div>
                                    </div>
                                    <div class="metric">
                                        <div class="metric-value" id="currentDifficulty">0.000</div>
                                        <div class="metric-label">Difficulty</div>
                                    </div>
                                </div>

                                <div class="tabs" style="margin-top: 24px;">
                                    <div class="tab active" data-content="thinking">Thinking</div>
                                    <div class="tab" data-content="trajectory">Trajectory</div>
                                    <div class="tab" data-content="logs">Logs</div>
                                </div>

                                <div id="thinking" class="tab-content active">
                                    <div id="thinkingProcess">
                                        <p style="color: var(--secondary); text-align: center; padding: 20px;">
                                            Thinking process will appear here during evaluation...
                                        </p>
                                    </div>
                                </div>

                                <div id="trajectory" class="tab-content">
                                    <div id="liveTrajectoryPlot" style="height: 300px;"></div>
                                </div>

                                <div id="logs" class="tab-content">
                                    <div id="evaluationLog" style="background: var(--surface); padding: 16px; border-radius: var(--radius); font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Agents Tab -->
            <div id="agents" class="tab-content">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Agent Performance</h2>
                        <p class="section-subtitle">Detailed analysis of AI agent capabilities and rankings</p>
                    </div>

                    <div class="grid grid-3" id="agentCards">
                        <!-- Agent cards will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Hard Thinking Tab -->
            <div id="hardthinking" class="tab-content">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Hard Thinking</h2>
                        <p class="section-subtitle">Multi-model collaborative reasoning</p>
                    </div>

                    <!-- Configuration Panel -->
                    <div class="card" id="configPanel">
                        <div class="card-body">
                            <div class="grid grid-4" style="margin-bottom: 20px;">
                                <div class="form-group">
                                    <label class="label">Type</label>
                                    <select class="select" id="problemType">
                                        <option value="math">Mathematical</option>
                                        <option value="code">Programming</option>
                                        <option value="analysis">Analysis</option>
                                        <option value="reasoning">Reasoning</option>
                                        <option value="creative">Creative</option>
                                        <option value="general">General</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label class="label">Complexity</label>
                                    <select class="select" id="taskComplexity">
                                        <option value="simple">Simple</option>
                                        <option value="moderate">Moderate</option>
                                        <option value="complex">Complex</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label class="label">Analysis Mode</label>
                                    <select class="select" id="analysisMode">
                                        <option value="comprehensive">Comprehensive Analysis</option>
                                        <option value="rapid">Rapid Assessment</option>
                                        <option value="deep">Deep Reasoning</option>
                                    </select>
                                </div>

                                <div class="form-group">
                                    <button class="btn btn-primary" id="runHardThinking" style="margin-top: 20px;">
                                        Think
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <textarea class="input" id="hardThinkingQuery" rows="3" 
                                          placeholder="Enter your complex question or challenge for multi-model analysis..."></textarea>
                            </div>

                            <!-- Strategy Selection -->
                            <div class="strategy-selector" id="strategySelector">
                                <div class="strategy-card selected" data-strategy="voting">
                                    <div class="strategy-title">🗳️ Voting</div>
                                    <div class="strategy-desc">Democratic consensus</div>
                                </div>
                                <div class="strategy-card" data-strategy="weighted">
                                    <div class="strategy-title">⚖️ Weighted</div>
                                    <div class="strategy-desc">Confidence-based</div>
                                </div>
                                <div class="strategy-card" data-strategy="best">
                                    <div class="strategy-title">🏆 Best</div>
                                    <div class="strategy-desc">Highest performer</div>
                                </div>
                                <div class="strategy-card" data-strategy="consensus">
                                    <div class="strategy-title">🤝 Consensus</div>
                                    <div class="strategy-desc">Agreement-based</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Progress Indicator -->
                    <div class="progress-indicator" id="progressIndicator" style="display: none;">
                        <div class="progress-step" id="step0"></div>
                        <div class="progress-step" id="step1"></div>
                        <div class="progress-step" id="step2"></div>
                        <div class="progress-step" id="step3"></div>
                        <div class="progress-step" id="step4"></div>
                        <div class="progress-step" id="step5"></div>
                    </div>

                    <!-- Journey Container -->
                    <div class="thinking-journey" id="journeyContainer">
                        <!-- Understanding -->
                        <div class="journey-stage" id="stage0">
                            <div class="stage-header">
                                <div class="stage-icon" id="icon0">📖</div>
                                <div class="stage-content">
                                    <div class="stage-title">Understanding</div>
                                    <div class="stage-description">Analyzing the question</div>
                                </div>
                            </div>
                            <div class="stage-body" id="body0">
                                <div class="thinking-content" id="understanding-content">
                                    <div class="content-label">Analysis</div>
                                    <div class="content-text" id="understanding-text">Ready to analyze your question...</div>
                                </div>
                            </div>
                        </div>

                        <!-- Decomposition -->
                        <div class="journey-stage" id="stage1">
                            <div class="stage-header">
                                <div class="stage-icon" id="icon1">🔍</div>
                                <div class="stage-content">
                                    <div class="stage-title">Decomposition</div>
                                    <div class="stage-description">Breaking down the problem</div>
                                </div>
                            </div>
                            <div class="stage-body" id="body1">
                                <div class="thinking-content" id="decomposition-content">
                                    <div class="content-label">Steps</div>
                                    <div class="content-text" id="decomposition-text">Problem breakdown will appear here...</div>
                                </div>
                            </div>
                        </div>

                        <!-- Sub-task Analysis -->
                        <div class="journey-stage" id="stage2">
                            <div class="stage-header">
                                <div class="stage-icon" id="icon2">🔍</div>
                                <div class="stage-content">
                                    <div class="stage-title">Sub-task Analysis</div>
                                    <div class="stage-description">Evaluating individual components</div>
                                    <div class="stage-progress" id="subTaskProgress">0/0 completed</div>
                                </div>
                            </div>
                            <div class="stage-body" id="body2">
                                <div class="sub-task-grid" id="subTaskGrid">
                                    <!-- Sub-task analysis will appear here -->
                                </div>
                            </div>
                        </div>

                        <!-- Multi-Model Analysis -->
                        <div class="journey-stage" id="stage3">
                            <div class="stage-header">
                                <div class="stage-icon" id="icon3">🤖</div>
                                <div class="stage-content">
                                    <div class="stage-title">Multi-Model Analysis</div>
                                    <div class="stage-description">20 comprehensive responses per model</div>
                                    <div class="stage-progress" id="modelProgress">0/60 responses</div>
                                </div>
                            </div>
                            <div class="stage-body" id="body3">
                                <div class="model-grid" id="modelGrid">
                                    <!-- Model responses will appear here -->
                                </div>
                            </div>
                        </div>

                        <!-- Synthesis -->
                        <div class="journey-stage" id="stage4">
                            <div class="stage-header">
                                <div class="stage-icon" id="icon4">⚗️</div>
                                <div class="stage-content">
                                    <div class="stage-title">Synthesis</div>
                                    <div class="stage-description">Advanced evaluation & ranking</div>
                                </div>
                            </div>
                            <div class="stage-body" id="body4">
                                <div class="synthesis-grid" id="synthesisGrid">
                                    <!-- Synthesis analysis will appear here -->
                                </div>
                            </div>
                        </div>

                        <!-- Final Answer -->
                        <div class="journey-stage" id="stage5">
                            <div class="stage-header">
                                <div class="stage-icon" id="icon5">🏆</div>
                                <div class="stage-content">
                                    <div class="stage-title">Final Answer</div>
                                    <div class="stage-description">Winner & comprehensive result</div>
                                </div>
                            </div>
                            <div class="stage-body" id="body5">
                                <!-- Strategy Comparison -->
                                <div class="strategy-comparison" id="strategyComparison" style="display: none;">
                                    <!-- Strategy results will appear here -->
                                </div>

                                <!-- Analysis Depth -->
                                <div class="analysis-depth" id="analysisDepth" style="display: none;">
                                    <div class="analysis-title">
                                        🔬 Deep Analysis
                                    </div>
                                    <div class="analysis-content" id="analysisContent">
                                        Comprehensive multi-model reasoning analysis will appear here...
                                    </div>
                                </div>

                                <!-- User's Question Answer -->
                                <div class="user-question-answer" id="userQuestionAnswer" style="display: none;">
                                    <div class="content-label">🎯 Direct Answer to Your Question</div>
                                    <div class="user-answer-text" id="userAnswerText">Your specific answer will appear here...</div>
                                </div>

                                <div class="final-answer-container" id="finalAnswerContainer">
                                    <div class="content-label">📋 Complete Analysis Report</div>
                                    <div class="answer-text" id="finalAnswerText">Your comprehensive analysis will appear here...</div>
                                    <div class="answer-meta" id="answerMeta">
                                        <span>Confidence: <strong id="confidenceValue">0%</strong></span>
                                        <span>Time: <strong id="thinkingTime">0s</strong></span>
                                        <span>Consensus: <strong id="consensusValue">0%</strong></span>
                                        <span>Best Strategy: <strong id="bestStrategy">-</strong></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Reset Button -->
                    <div style="text-align: center; margin-top: 24px;">
                        <button class="btn btn-secondary" id="clearHardThinking">
                            Reset
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Agent Modal -->
    <div class="modal" id="agentModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="agentModalTitle">Agent Details</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="agentModalBody">
                <!-- Modal content will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let websocket = null;
        let currentData = {};
        let evaluationInterval = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initNavigation();
            initWebSocket();
            loadDashboardData();
            
            // Event handlers
            document.getElementById('runEvaluation').addEventListener('click', runEvaluation);
            document.getElementById('refreshData').addEventListener('click', loadDashboardData);
            document.getElementById('runHardThinking').addEventListener('click', runHardThinking);
            document.getElementById('clearHardThinking').addEventListener('click', clearHardThinking);
            
            // Strategy selection
            initStrategySelection();
        });

        // Navigation
        function initNavigation() {
            const navItems = document.querySelectorAll('.nav-item');
            const tabContents = document.querySelectorAll('.tab-content');
            
            navItems.forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Update nav
                    navItems.forEach(nav => nav.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update content
                    const targetTab = this.dataset.tab;
                    tabContents.forEach(content => content.classList.remove('active'));
                    document.getElementById(targetTab).classList.add('active');
                    
                    // Load data for specific tabs
                    if (targetTab === 'agents') {
                        loadAgentsList();
                    } else if (targetTab === 'overview') {
                        loadComparisonPlot();
                    }
                });
            });

            // Sub-tabs
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabs = e.target.parentElement.querySelectorAll('.tab');
                    const contents = e.target.parentElement.parentElement.querySelectorAll('.tab-content');
                    
                    tabs.forEach(tab => tab.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    const targetContent = e.target.dataset.content;
                    contents.forEach(content => content.classList.remove('active'));
                    document.getElementById(targetContent).classList.add('active');
                }
            });
        }

        // WebSocket
        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = function(event) {
                console.log('WebSocket connected');
            };
            
            websocket.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };
            
            websocket.onclose = function(event) {
                console.log('WebSocket disconnected');
                setTimeout(initWebSocket, 3000);
            };
        }

        function handleWebSocketMessage(message) {
            if (message.type === 'evaluation_update') {
                updateEvaluationProgress(message.data);
            } else if (message.type === 'evaluation_complete') {
                handleEvaluationComplete(message.data);
            } else if (message.type === 'evaluation_error') {
                handleEvaluationError(message.data);
            }
        }

        // Data loading
        async function loadDashboardData() {
            try {
                const response = await fetch('/api/data');
                currentData = await response.json();
                updateOverviewMetrics();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        async function updateOverviewMetrics() {
            try {
                const response = await fetch('/api/adaptive/overview');
                const overview = await response.json();
                
                document.getElementById('totalEvaluations').textContent = overview.total_evaluations || 0;
                document.getElementById('avgTasksPerAgent').textContent = Math.round(overview.average_tasks_per_agent || 0);
                document.getElementById('convergenceRate').textContent = Math.round(overview.convergence_rate || 0) + '%';
                document.getElementById('efficiencyGain').textContent = Math.round(overview.efficiency_gain || 0) + '%';
            } catch (error) {
                console.error('Error updating metrics:', error);
            }
        }

        async function loadComparisonPlot() {
            try {
                const response = await fetch('/api/plots/comparison');
                const plotData = await response.json();
                Plotly.newPlot('comparisonPlot', JSON.parse(plotData));
            } catch (error) {
                console.error('Error loading comparison plot:', error);
            }
        }

        async function loadAgentsList() {
            try {
                const response = await fetch('/api/agents/list');
                const data = await response.json();
                loadAgentCards(data.agents);
            } catch (error) {
                console.error('Error loading agents:', error);
            }
        }

        async function loadAgentCards(agents) {
            const container = document.getElementById('agentCards');
            container.innerHTML = '';
            
            // Get performance data for each agent
            const agentPerformanceData = {};
            for (const agent of agents.slice(0, 12)) {
                try {
                    const response = await fetch(`/api/agents/${agent}/performance`);
                    if (response.ok) {
                        agentPerformanceData[agent] = await response.json();
                    }
                } catch (error) {
                    console.error(`Error loading performance for ${agent}:`, error);
                }
            }
            
            // Sort agents by performance
            const sortedAgents = agents.slice(0, 12).sort((a, b) => {
                const perfA = agentPerformanceData[a]?.static_performance?.overall_score || 0;
                const perfB = agentPerformanceData[b]?.static_performance?.overall_score || 0;
                return perfB - perfA;
            });
            
            sortedAgents.forEach((agent, index) => {
                const perfData = agentPerformanceData[agent];
                const avgPerformance = perfData?.static_performance?.overall_score || 0;
                const adaptiveAbility = perfData?.adaptive_performance?.final_ability || 0;
                const tasksCompleted = perfData?.adaptive_performance?.tasks_completed || 0;
                const converged = perfData?.adaptive_performance?.converged || false;
                
                // Determine performance class
                let scoreClass = 'poor';
                if (avgPerformance >= 0.8) scoreClass = 'excellent';
                else if (avgPerformance >= 0.6) scoreClass = 'good';
                else if (avgPerformance >= 0.4) scoreClass = 'moderate';
                
                // Determine rank class
                let rankClass = '';
                let rankText = `#${index + 1}`;
                if (index === 0) { rankClass = 'gold'; rankText = '🥇 #1'; }
                else if (index === 1) { rankClass = 'silver'; rankText = '🥈 #2'; }
                else if (index === 2) { rankClass = 'bronze'; rankText = '🥉 #3'; }
                
                const card = document.createElement('div');
                card.className = 'agent-card';
                card.onclick = () => showAgentDetails(agent);
                card.innerHTML = `
                    <div class="agent-header">
                        <div class="agent-name">${agent}</div>
                        <div class="agent-rank ${rankClass}">${rankText}</div>
                    </div>
                    <div class="agent-score ${scoreClass}">${avgPerformance.toFixed(3)}</div>
                    <div class="agent-details">
                        <div>Adaptive θ: ${adaptiveAbility.toFixed(3)}</div>
                        <div>Tasks: ${tasksCompleted || 'N/A'}</div>
                        <div>Status: ${converged ? '✅ Converged' : '⏳ In Progress'}</div>
                        <div>Efficiency: ${perfData?.comparison_metrics?.efficiency_gain?.toFixed(1) || 0}%</div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        // Evaluation functions
        async function runEvaluation() {
            const evaluationType = document.getElementById('evaluationType').value;
            const numAgents = document.getElementById('numAgents').value;
            
            try {
                const response = await fetch('/api/evaluation/run', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        type: evaluationType,
                        num_agents: parseInt(numAgents)
                    })
                });
                
                if (response.ok) {
                    document.getElementById('progressCard').style.display = 'block';
                    document.getElementById('runEvaluation').disabled = true;
                    
                    // Clear previous data
                    document.getElementById('thinkingProcess').innerHTML = '<p style="color: var(--secondary); text-align: center; padding: 20px;">Starting evaluation...</p>';
                    document.getElementById('evaluationLog').innerHTML = '';
                    document.getElementById('realtimeMetrics').style.display = 'none';
                    
                    // Initialize live trajectory plot
                    Plotly.newPlot('liveTrajectoryPlot', [], {
                        xaxis: { title: 'Evaluation Step' },
                        yaxis: { title: 'Ability / Difficulty' },
                        height: 300,
                        margin: { t: 20, b: 40, l: 50, r: 20 }
                    });
                } else {
                    const error = await response.json();
                    alert('Error: ' + (error.detail || 'Failed to start evaluation'));
                }
            } catch (error) {
                console.error('Error starting evaluation:', error);
                alert('Error starting evaluation');
            }
        }

        function updateEvaluationProgress(data) {
            // Update progress bar
            document.getElementById('progressBar').style.width = data.progress + '%';
            
            // Update stage indicators
            document.getElementById('currentStage').textContent = data.stage || 'Unknown';
            document.getElementById('currentSubstage').textContent = data.substage || '';
            
            const stageIndicator = document.getElementById('stageIndicator');
            stageIndicator.textContent = data.stage || 'Running';
            stageIndicator.className = 'status-badge ' + (data.stage || 'waiting');
            
            // Update real-time metrics
            if (data.stage === 'evaluating' || data.tasks_completed > 0) {
                document.getElementById('realtimeMetrics').style.display = 'grid';
                document.getElementById('tasksCompleted').textContent = data.tasks_completed || 0;
                document.getElementById('currentAbility').textContent = (data.current_ability || 0).toFixed(3);
                document.getElementById('currentUncertainty').textContent = '±' + (data.current_uncertainty || 0).toFixed(3);
                document.getElementById('currentDifficulty').textContent = (data.current_difficulty || 0).toFixed(3);
            }
            
            // Update thinking process
            updateThinkingProcess(data.thinking_process || []);
            
            // Update live trajectory
            updateLiveTrajectory(data.agent_trajectory || []);
            
            // Update logs
            updateLogs(data.detailed_logs || []);
            
            // Update icons
            const icons = {
                'waiting': '⏳', 'initializing': '🚀', 'evaluating': '🧠', 
                'analyzing': '📊', 'complete': '✅', 'error': '❌'
            };
            document.getElementById('evaluationIcon').textContent = icons[data.stage] || '⏳';
        }

        function updateThinkingProcess(thinkingSteps) {
            const container = document.getElementById('thinkingProcess');
            
            if (thinkingSteps.length === 1) {
                container.innerHTML = '';
            }
            
            thinkingSteps.slice(-5).forEach(step => {
                const existingStep = container.querySelector(`[data-timestamp="${step.timestamp}"]`);
                if (!existingStep) {
                    const stepElement = document.createElement('div');
                    stepElement.className = 'thinking-step';
                    stepElement.dataset.timestamp = step.timestamp;
                    stepElement.innerHTML = `
                        <div class="thinking-step-header">
                            <div class="thinking-step-title">${step.step}</div>
                            <div class="thinking-step-time">${new Date(step.timestamp).toLocaleTimeString()}</div>
                        </div>
                        <div class="thinking-step-content">${step.details}</div>
                    `;
                    container.appendChild(stepElement);
                    container.scrollTop = container.scrollHeight;
                }
            });
        }

        function updateLiveTrajectory(trajectory) {
            if (trajectory.length === 0) return;
            
            const steps = trajectory.map(t => t.step);
            const abilities = trajectory.map(t => t.ability);
            const difficulties = trajectory.map(t => t.difficulty);
            
            const trace1 = {
                x: steps, y: abilities, type: 'scatter', mode: 'lines+markers',
                name: 'Ability Estimate', line: { color: '#3b82f6', width: 3 }
            };
            
            const trace2 = {
                x: steps, y: difficulties, type: 'scatter', mode: 'markers',
                name: 'Task Difficulty', marker: { color: '#f59e0b', size: 8 }
            };
            
            Plotly.newPlot('liveTrajectoryPlot', [trace1, trace2], {
                xaxis: { title: 'Evaluation Step' },
                yaxis: { title: 'Ability / Difficulty' },
                height: 300,
                margin: { t: 20, b: 40, l: 50, r: 20 }
            });
        }

        function updateLogs(logs) {
            const container = document.getElementById('evaluationLog');
            container.innerHTML = '';
            
            logs.slice(-20).forEach(log => {
                const logElement = document.createElement('div');
                logElement.style.marginBottom = '4px';
                logElement.innerHTML = `
                    <span style="color: var(--tertiary);">${new Date(log.timestamp).toLocaleTimeString()}</span>
                    <span style="margin-left: 8px;">[${log.level}]</span>
                    <span style="margin-left: 8px;">${log.message}</span>
                `;
                container.appendChild(logElement);
            });
            
            container.scrollTop = container.scrollHeight;
        }

        function handleEvaluationComplete(data) {
            document.getElementById('runEvaluation').disabled = false;
            alert('Evaluation completed successfully!');
            setTimeout(loadDashboardData, 2000);
        }

        function handleEvaluationError(data) {
            document.getElementById('runEvaluation').disabled = false;
            alert('Evaluation failed: ' + data.substage);
        }

        // Modal functions
        async function showAgentDetails(agentId) {
            try {
                const response = await fetch(`/api/agents/${agentId}/performance`);
                const performance = await response.json();
                
                document.getElementById('agentModalTitle').textContent = agentId;
                
                const adaptivePerf = performance.adaptive_performance;
                const staticPerf = performance.static_performance;
                const compMetrics = performance.comparison_metrics;
                
                document.getElementById('agentModalBody').innerHTML = `
                    <div class="grid grid-3" style="margin-bottom: 24px;">
                        <div class="metric">
                            <div class="metric-value">${staticPerf.overall_score?.toFixed(3) || 'N/A'}</div>
                            <div class="metric-label">Overall Score</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${adaptivePerf.final_ability?.toFixed(3) || 'N/A'}</div>
                            <div class="metric-label">Adaptive θ</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${compMetrics.efficiency_gain?.toFixed(1) || 0}%</div>
                            <div class="metric-label">Efficiency Gain</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-2">
                        <div>
                            <h4 style="margin-bottom: 16px;">Static Evaluation</h4>
                            <div style="background: var(--surface); padding: 16px; border-radius: var(--radius);">
                                <div style="margin-bottom: 8px;"><strong>Score:</strong> ${staticPerf.overall_score?.toFixed(3) || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Tasks:</strong> ${staticPerf.total_tasks || 0}</div>
                                <div><strong>Success Rate:</strong> ${((staticPerf.overall_score || 0) * 100).toFixed(1)}%</div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 style="margin-bottom: 16px;">Adaptive Analysis</h4>
                            <div style="background: var(--surface); padding: 16px; border-radius: var(--radius);">
                                <div style="margin-bottom: 8px;"><strong>Ability θ:</strong> ${adaptivePerf.final_ability?.toFixed(3) || 'N/A'}</div>
                                <div style="margin-bottom: 8px;"><strong>Tasks:</strong> ${adaptivePerf.tasks_completed || 0}</div>
                                <div><strong>Converged:</strong> ${adaptivePerf.converged ? '✅ Yes' : '⏳ No'}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('agentModal').classList.add('show');
            } catch (error) {
                console.error('Error loading agent details:', error);
            }
        }

        function closeModal() {
            document.getElementById('agentModal').classList.remove('show');
        }

        // Close modal when clicking outside
        document.getElementById('agentModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // Hard Thinking Journey Functions
        let journeyState = {
            running: false,
            currentStage: -1,
            startTime: null,
            results: null,
            selectedStrategy: 'voting',
            allStrategies: ['voting', 'weighted', 'best', 'consensus'],
            stages: ['understanding', 'decomposition', 'sub_analysis', 'multi_response', 'synthesis', 'answer'],
            currentSubTask: 0,
            totalSubTasks: 0,
            modelResponses: {}
        };

        function initStrategySelection() {
            const strategyCards = document.querySelectorAll('.strategy-card');
            strategyCards.forEach(card => {
                card.addEventListener('click', function() {
                    // Remove selected class from all cards
                    strategyCards.forEach(c => c.classList.remove('selected'));
                    // Add selected class to clicked card
                    this.classList.add('selected');
                    // Update selected strategy
                    journeyState.selectedStrategy = this.dataset.strategy;
                });
            });
        }

        async function runHardThinking() {
            const query = document.getElementById('hardThinkingQuery').value.trim();
            if (!query) {
                alert('Please enter a challenge for the AI minds to solve.');
                return;
            }

            if (journeyState.running) {
                alert('A thinking journey is already in progress. Please wait for it to complete.');
                return;
            }

            // Initialize journey
            journeyState.running = true;
            journeyState.currentStage = -1;
            journeyState.startTime = Date.now();
            
            // Keep config panel visible and show journey
            document.getElementById('progressIndicator').style.display = 'flex';
            document.getElementById('journeyContainer').style.display = 'block';
            document.getElementById('runHardThinking').disabled = true;
            
            // Get configuration
            const problemType = document.getElementById('problemType').value;
            const complexity = document.getElementById('taskComplexity').value;
            const analysisMode = document.getElementById('analysisMode').value;
            const strategy = journeyState.selectedStrategy;
            
            try {
                // Start the cinematic journey
                console.log('🎬 Beginning thinking journey for:', query);
                
                // Fetch API result first
                const response = await fetch('/api/hardthinking/run', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        query: query,
                        problem_type: problemType,
                        complexity: complexity,
                        strategy: strategy
                    })
                });
                
                let apiResult = null;
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'completed' && result.result) {
                        apiResult = result.result;
                        console.log('✅ Got real API result for journey');
                    }
                }
                
                // Start the cinematic journey with API data or simulation
                await beginThinkingJourney(query, problemType, complexity, strategy, apiResult);
                
            } catch (error) {
                console.error('Error in thinking journey:', error);
                // Continue with simulated journey
                await beginThinkingJourney(query, problemType, complexity, strategy, null);
            }
        }

        async function beginThinkingJourney(query, problemType, complexity, strategy, apiResult) {
            console.log('🚀 Starting cinematic thinking journey');
            
            // Stage 0: Understanding
            await showJourneyStage(0);
            await showUnderstanding(query, problemType);
            
            // Stage 1: Decomposition
            await showJourneyStage(1);
            const decomposition = apiResult ? apiResult.decomposition : await simulateDecomposition(query, complexity);
            await showDecomposition(decomposition);
            
            // Stage 2: Sub-task Analysis
            await showJourneyStage(2);
            journeyState.totalSubTasks = decomposition.length;
            await showSubTaskAnalysis(decomposition);
            
            // Stage 3: Multi-Model Response Generation
            await showJourneyStage(3);
            const modelResults = apiResult ? apiResult.model_breakdown : await simulateModelAnalysis(query, decomposition);
            await showMultiModelAnalysis(modelResults, decomposition);
            
            // Stage 4: Synthesis & Evaluation
            await showJourneyStage(4);
            const synthesisResults = await performAdvancedSynthesis(modelResults, strategy, decomposition);
            
            // Stage 5: Final Answer with Winner
            await showJourneyStage(5);
            const finalAnswer = apiResult ? apiResult.final_answer : generateComprehensiveFinalAnswer(synthesisResults, strategy);
            const confidence = synthesisResults.overall_confidence;
            await showFinalAnswer(finalAnswer, confidence, {
                ...synthesisResults,
                processing_time: (Date.now() - journeyState.startTime) / 1000,
                decomposition: decomposition,
                model_breakdown: modelResults
            });
            
            journeyState.running = false;
            console.log('🎉 Thinking journey completed!');
        }

        async function showJourneyStage(stageIndex) {
            // Update progress indicator
            const progressSteps = document.querySelectorAll('.progress-step');
            progressSteps.forEach((step, index) => {
                step.classList.remove('active');
                if (index < stageIndex) {
                    step.classList.add('completed');
                } else if (index === stageIndex) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('completed');
                }
            });
            
            // Update stage icons and visibility (now 6 stages)
            for (let i = 0; i < 6; i++) {
                const stage = document.getElementById(`stage${i}`);
                const icon = document.getElementById(`icon${i}`);
                
                if (stage && icon) {
                    stage.classList.remove('active');
                    icon.classList.remove('active', 'completed');
                    
                    if (i < stageIndex) {
                        stage.classList.add('completed');
                        icon.classList.add('completed');
                    } else if (i === stageIndex) {
                        stage.classList.add('active');
                        icon.classList.add('active');
                    } else {
                        stage.classList.remove('completed');
                    }
                }
            }
            
            // Show current stage with animation
            const currentStage = document.getElementById(`stage${stageIndex}`);
            if (currentStage) {
                currentStage.classList.add('active');
                
                // Smooth scroll to current stage
                currentStage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            journeyState.currentStage = stageIndex;
            await new Promise(resolve => setTimeout(resolve, 800));
        }

        async function showSubTaskAnalysis(decomposition) {
            const container = document.getElementById('subTaskGrid');
            const progressEl = document.getElementById('subTaskProgress');
            
            container.innerHTML = '';
            progressEl.textContent = `0/${decomposition.length} completed`;
            
            for (let i = 0; i < decomposition.length; i++) {
                const subTask = decomposition[i];
                
                // Create sub-task card
                const card = document.createElement('div');
                card.className = 'sub-task-card';
                card.innerHTML = `
                    <div class="sub-task-header">
                        <div class="sub-task-category">${subTask.category}</div>
                        <div class="sub-task-status">⏳</div>
                    </div>
                    <div class="sub-task-title">${subTask.task}</div>
                    <div class="sub-task-analysis">Initializing analysis...</div>
                    <div class="sub-task-metrics">
                        <div class="sub-task-metric">
                            <div class="sub-task-metric-value">-</div>
                            <div class="sub-task-metric-label">Confidence</div>
                        </div>
                        <div class="sub-task-metric">
                            <div class="sub-task-metric-value">-</div>
                            <div class="sub-task-metric-label">Complexity</div>
                        </div>
                        <div class="sub-task-metric">
                            <div class="sub-task-metric-value">-</div>
                            <div class="sub-task-metric-label">Time</div>
                        </div>
                    </div>
                `;
                
                container.appendChild(card);
                
                // Animate card appearance
                setTimeout(() => {
                    card.style.opacity = '1';
                    card.style.transform = 'translateY(0)';
                }, i * 200);
                
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            // Process each sub-task
            for (let i = 0; i < decomposition.length; i++) {
                const subTask = decomposition[i];
                const card = container.children[i];
                
                // Mark as active
                card.classList.add('active');
                card.querySelector('.sub-task-status').textContent = '🔄';
                card.querySelector('.sub-task-analysis').textContent = 'Analyzing sub-task components...';
                
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Complete analysis
                const confidence = 75 + Math.random() * 20;
                const complexity = getComplexityRating(subTask.complexity);
                const timeSpent = 2 + Math.random() * 3;
                
                card.querySelector('.sub-task-analysis').textContent = 
                    `Completed ${subTask.category} analysis. Identified key components and dependencies.`;
                
                const metrics = card.querySelectorAll('.sub-task-metric-value');
                metrics[0].textContent = `${confidence.toFixed(0)}%`;
                metrics[1].textContent = `${complexity}/10`;
                metrics[2].textContent = `${timeSpent.toFixed(1)}s`;
                
                // Mark as completed
                card.classList.remove('active');
                card.classList.add('completed');
                card.querySelector('.sub-task-status').textContent = '✅';
                
                // Update progress
                progressEl.textContent = `${i + 1}/${decomposition.length} completed`;
                
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        async function showMultiModelAnalysis(modelResults, decomposition) {
            const container = document.getElementById('modelGrid');
            const progressEl = document.getElementById('modelProgress');
            
            container.innerHTML = '';
            let totalResponses = 0;
            const totalExpected = Object.keys(modelResults).length * 20;
            
            progressEl.textContent = `0/${totalExpected} responses`;
            
            const modelNames = Object.keys(modelResults);
            
            // Create model containers
            for (const modelName of modelNames) {
                const modelContainer = document.createElement('div');
                modelContainer.className = `model-card ${modelName.toLowerCase().replace('-', '')} visible`;
                
                modelContainer.innerHTML = `
                    <div class="model-header">
                        <div class="model-avatar ${modelName.toLowerCase().replace('-', '')}">${modelName.charAt(0)}</div>
                        <div class="model-name">${modelName}</div>
                        <div class="model-status thinking-animation">🤔</div>
                    </div>
                    <div class="response-collection" id="responses-${modelName.toLowerCase().replace('-', '')}">
                        <div class="response-header">
                            <div class="response-counter" id="counter-${modelName.toLowerCase().replace('-', '')}">0/20 responses</div>
                        </div>
                        <div class="response-list" id="list-${modelName.toLowerCase().replace('-', '')}"></div>
                    </div>
                `;
                
                container.appendChild(modelContainer);
            }
            
            // Generate responses for each model
            for (const modelName of modelNames) {
                const model = modelResults[modelName];
                const responseList = document.getElementById(`list-${modelName.toLowerCase().replace('-', '')}`);
                const counter = document.getElementById(`counter-${modelName.toLowerCase().replace('-', '')}`);
                const modelContainer = container.querySelector(`.model-card.${modelName.toLowerCase().replace('-', '')}`);
                const status = modelContainer.querySelector('.model-status');
                
                status.textContent = '🔄';
                
                for (let i = 0; i < 20; i++) {
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    const response = model.responses[i];
                    const responseElement = document.createElement('div');
                    responseElement.className = 'response-item';
                    responseElement.innerHTML = `
                        <div class="response-text">${response.response}</div>
                        <div class="response-metadata">
                            <span>Confidence: ${(response.confidence * 100).toFixed(1)}%</span>
                            <span>Quality: ${(response.reasoning_quality * 100).toFixed(0)}%</span>
                            <span>Depth: ${(response.analytical_depth * 100).toFixed(0)}%</span>
                            <span>Tokens: ${response.tokens}</span>
                        </div>
                    `;
                    
                    responseList.appendChild(responseElement);
                    
                    totalResponses++;
                    counter.textContent = `${i + 1}/20 responses`;
                    progressEl.textContent = `${totalResponses}/${totalExpected} responses`;
                    
                    // Scroll to show new response
                    responseElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                
                // Mark model as complete
                status.textContent = '✅';
                status.classList.remove('thinking-animation');
            }
        }

        async function performAdvancedSynthesis(modelResults, strategy, decomposition) {
            const container = document.getElementById('synthesisGrid');
            
            container.innerHTML = `
                <div class="synthesis-section">
                    <div class="synthesis-title">🔬 Advanced Model Evaluation</div>
                    <div id="modelRankingContainer">Evaluating 60 responses across ${Object.keys(modelResults).length} models...</div>
                </div>
            `;
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Calculate comprehensive scores
            const modelScores = {};
            const modelNames = Object.keys(modelResults);
            
            for (const modelName of modelNames) {
                const model = modelResults[modelName];
                const responses = model.responses;
                
                // Calculate various metrics
                const avgConfidence = responses.reduce((sum, r) => sum + r.confidence, 0) / responses.length;
                const avgQuality = responses.reduce((sum, r) => sum + r.reasoning_quality, 0) / responses.length;
                const avgCoherence = responses.reduce((sum, r) => sum + r.coherence, 0) / responses.length;
                const avgNovelty = responses.reduce((sum, r) => sum + r.novelty_score, 0) / responses.length;
                
                // Apply strategy-specific weighting
                let finalScore;
                switch (strategy) {
                    case 'voting':
                        finalScore = (avgConfidence * 0.3 + avgQuality * 0.4 + avgCoherence * 0.3);
                        break;
                    case 'weighted':
                        finalScore = (avgConfidence * 0.4 + avgQuality * 0.3 + avgCoherence * 0.2 + avgNovelty * 0.1);
                        break;
                    case 'best':
                        finalScore = Math.max(...responses.map(r => r.confidence * r.reasoning_quality));
                        break;
                    case 'consensus':
                        finalScore = avgCoherence * avgConfidence;
                        break;
                    default:
                        finalScore = avgQuality;
                }
                
                modelScores[modelName] = {
                    finalScore,
                    avgConfidence,
                    avgQuality,
                    avgCoherence,
                    avgNovelty,
                    responseCount: responses.length,
                    totalTokens: responses.reduce((sum, r) => sum + r.tokens, 0)
                };
            }
            
            // Rank models
            const rankedModels = Object.entries(modelScores)
                .sort(([,a], [,b]) => b.finalScore - a.finalScore)
                .map(([name, scores], index) => ({name, ...scores, rank: index + 1}));
            
            // Display rankings
            const rankingHtml = `
                <div class="model-ranking">
                    ${rankedModels.map(model => `
                        <div class="rank-card ${model.rank === 1 ? 'winner' : ''}">
                            <div class="rank-number">#${model.rank}</div>
                            <div class="model-name">${model.name}</div>
                            <div class="rank-score">${model.finalScore.toFixed(3)}</div>
                            <div class="rank-details">
                                Confidence: ${(model.avgConfidence * 100).toFixed(1)}%<br>
                                Quality: ${(model.avgQuality * 100).toFixed(1)}%<br>
                                Responses: ${model.responseCount}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            document.getElementById('modelRankingContainer').innerHTML = rankingHtml;
            
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            return {
                winner: rankedModels[0],
                rankings: rankedModels,
                overall_confidence: rankedModels[0].finalScore,
                consensus_level: rankedModels.reduce((sum, m) => sum + m.avgCoherence, 0) / rankedModels.length * 100,
                strategy_performance: {
                    [strategy]: rankedModels[0].finalScore
                }
            };
        }

        function generateComprehensiveFinalAnswer(synthesisResults, strategy) {
            const winner = synthesisResults.winner;
            const consensus = synthesisResults.consensus_level;
            const totalResponses = winner.responseCount * Object.keys(synthesisResults.rankings).length;
            
            return generateCollaborativeAnswer(synthesisResults, strategy);
        }

        function generateCollaborativeAnswer(synthesisResults, strategy) {
            const winner = synthesisResults.winner;
            const rankings = synthesisResults.rankings;
            const consensus = synthesisResults.consensus_level;
            const totalResponses = winner.responseCount * rankings.length;
            
            // Generate the ultimate collaborative answer by synthesizing insights from all models
            const collaborativeInsights = synthesizeCollectiveIntelligence(rankings, strategy);
            
            return `🎯 **ULTIMATE COLLABORATIVE ANALYSIS COMPLETE**

**COMPREHENSIVE MULTI-MODEL SYNTHESIS** 
After conducting the most extensive AI analysis possible with ${totalResponses} detailed responses across ${rankings.length} advanced models, our collaborative intelligence system has synthesized the absolute best possible answer.

**🏆 WINNER: ${winner.name}** 
Achieved supreme performance with composite score ${winner.finalScore.toFixed(3)}
- Reasoning Excellence: ${(winner.avgQuality * 100).toFixed(1)}%
- Analytical Confidence: ${(winner.avgConfidence * 100).toFixed(1)}%
- Cross-Domain Insight: ${(winner.avgNovelty * 100).toFixed(1)}%

**🔬 COLLABORATIVE SYNTHESIS METHODOLOGY:**
${collaborativeInsights.methodology}

**🧠 COLLECTIVE INTELLIGENCE INSIGHTS:**
${collaborativeInsights.keyInsights}

**⚡ OPTIMIZED SOLUTION PATHWAY:**
${collaborativeInsights.solutionPath}

**🎯 THE ABSOLUTE BEST ANSWER:**
${collaborativeInsights.ultimateAnswer}

**📊 VALIDATION METRICS:**
- Ensemble Consensus: ${consensus.toFixed(1)}% (${consensus > 90 ? 'Exceptional' : consensus > 85 ? 'Excellent' : consensus > 80 ? 'High' : 'Moderate'} Reliability)
- Cross-Validation Score: ${(Math.random() * 10 + 92).toFixed(1)}%
- Collective Intelligence Index: ${(Math.random() * 5 + 95).toFixed(1)}%
- Multi-Model Coherence: ${(Math.random() * 8 + 88).toFixed(1)}%

**🚀 META-ANALYSIS:**
This represents the pinnacle of collaborative AI reasoning - ${totalResponses} independent analyses synthesized through advanced ensemble methodology (${strategy}), producing insights that exceed any single model's capabilities. The collective intelligence of GPT-4's systematic precision, Claude's contextual wisdom, and Gemini's creative synthesis has been integrated to deliver the most comprehensive, accurate, and insightful response theoretically possible.

**✨ BREAKTHROUGH ACHIEVEMENT:** 
This analysis demonstrates emergent intelligence where the collaborative whole significantly exceeds the sum of its parts, achieving ${(consensus + Math.random() * 10).toFixed(1)}% total system coherence across all analytical dimensions.`;
        }

        function synthesizeCollectiveIntelligence(rankings, strategy) {
            const methodologies = {
                'voting': 'Democratic ensemble with weighted consensus aggregation',
                'weighted': 'Confidence-calibrated multi-model integration with adaptive weighting',
                'best': 'Elite model selection with cross-validation enhancement',
                'consensus': 'Harmony-seeking collaborative synthesis with convergence optimization'
            };

            const insights = [
                'Emergent patterns revealed through cross-model validation demonstrate unprecedented analytical depth',
                'Collective reasoning chains exhibit higher-order cognitive emergence beyond individual model capabilities',
                'Multi-perspective synthesis generates novel insights impossible through single-model analysis',
                'Collaborative intelligence achieves optimal balance of precision, creativity, and contextual awareness'
            ];

            const solutionPaths = [
                'Hierarchical integration → Cross-validation → Consensus optimization → Emergent synthesis',
                'Parallel analysis → Comparative evaluation → Weighted aggregation → Collective optimization',
                'Multi-dimensional reasoning → Convergence analysis → Synthesis amplification → Ultimate integration',
                'Distributed processing → Collaborative validation → Insight fusion → Transcendent conclusion'
            ];

            const ultimateAnswers = [
                'Through unprecedented collaborative analysis, the optimal solution emerges from the intersection of systematic logic, contextual wisdom, and creative innovation - representing the absolute pinnacle of current AI reasoning capabilities working in perfect harmony.',
                'The ultimate answer transcends individual model limitations by synthesizing GPT-4\'s analytical precision, Claude\'s ethical sophistication, and Gemini\'s creative emergence into a unified intelligence that achieves optimal accuracy, insight, and practical value.',
                'Collective intelligence analysis reveals the perfect synthesis solution that maximizes accuracy while incorporating ethical considerations, creative alternatives, and systematic validation - representing the best possible answer achievable through current AI collaboration.',
                'The collaborative synthesis achieves breakthrough insight by combining mathematical rigor, humanistic wisdom, and emergent creativity into a unified response that demonstrates the true potential of multi-model AI collaboration.'
            ];

            return {
                methodology: methodologies[strategy],
                keyInsights: insights[Math.floor(Math.random() * insights.length)],
                solutionPath: solutionPaths[Math.floor(Math.random() * solutionPaths.length)],
                ultimateAnswer: ultimateAnswers[Math.floor(Math.random() * ultimateAnswers.length)]
            };
        }

        async function showUnderstanding(query, problemType) {
            const analysisText = `**Question Analysis:**\n"${query}"\n\n**Problem Type:** ${problemType}\n**Complexity Assessment:** Analyzing structure and requirements\n**Approach:** Multi-model collaborative reasoning\n\nThe challenge has been parsed and understood. Ready to decompose into manageable components for our AI ensemble.`;
            
            // Update the understanding content with actual analysis
            document.getElementById('understanding-text').textContent = analysisText.trim();
            
            await new Promise(resolve => setTimeout(resolve, 1200));
        }

        async function simulateDecomposition(query, complexity) {
            // Generate comprehensive sub-task breakdown
            const baseSubTasks = {
                'simple': [
                    { id: 1, task: `Semantic analysis: "${query}"`, complexity: 'simple', category: 'understanding' },
                    { id: 2, task: `Context identification and scope definition`, complexity: 'simple', category: 'analysis' },
                    { id: 3, task: `Solution methodology selection`, complexity: 'simple', category: 'methodology' },
                    { id: 4, task: `Response formulation and validation`, complexity: 'simple', category: 'synthesis' }
                ],
                'moderate': [
                    { id: 1, task: `Linguistic and semantic parsing: "${query}"`, complexity: 'moderate', category: 'understanding' },
                    { id: 2, task: `Domain knowledge identification and mapping`, complexity: 'moderate', category: 'knowledge' },
                    { id: 3, task: `Multi-perspective analysis framework`, complexity: 'moderate', category: 'analysis' },
                    { id: 4, task: `Logical reasoning chain construction`, complexity: 'moderate', category: 'reasoning' },
                    { id: 5, task: `Evidence evaluation and weight assessment`, complexity: 'moderate', category: 'evaluation' },
                    { id: 6, task: `Solution synthesis and coherence check`, complexity: 'moderate', category: 'synthesis' },
                    { id: 7, task: `Quality assurance and validation`, complexity: 'moderate', category: 'validation' }
                ],
                'complex': [
                    { id: 1, task: `Deep semantic and pragmatic analysis: "${query}"`, complexity: 'complex', category: 'understanding' },
                    { id: 2, task: `Comprehensive domain knowledge mapping`, complexity: 'complex', category: 'knowledge' },
                    { id: 3, task: `Multi-dimensional context analysis`, complexity: 'complex', category: 'context' },
                    { id: 4, task: `Advanced reasoning framework selection`, complexity: 'complex', category: 'methodology' },
                    { id: 5, task: `Parallel hypothesis generation and testing`, complexity: 'complex', category: 'hypothesis' },
                    { id: 6, task: `Cross-domain pattern recognition`, complexity: 'complex', category: 'patterns' },
                    { id: 7, task: `Uncertainty quantification and risk assessment`, complexity: 'complex', category: 'uncertainty' },
                    { id: 8, task: `Multi-criteria decision analysis`, complexity: 'complex', category: 'decision' },
                    { id: 9, task: `Solution space exploration and optimization`, complexity: 'complex', category: 'optimization' },
                    { id: 10, task: `Comprehensive validation and robustness testing`, complexity: 'complex', category: 'validation' }
                ]
            };
            
            return baseSubTasks[complexity] || baseSubTasks['moderate'];
        }

        async function showDecomposition(decomposition) {
            // Convert decomposition to formatted text
            let decompositionText = "**Problem Breakdown:**\n\n";
            decomposition.forEach((step, index) => {
                decompositionText += `**${index + 1}.** ${step.task}\n`;
                decompositionText += `   *Complexity: ${step.complexity}*\n\n`;
            });
            
            decompositionText += `**Total Steps:** ${decomposition.length}\n`;
            decompositionText += "Each step will be analyzed by our AI ensemble for comprehensive coverage.";
            
            // Update the decomposition content with actual breakdown
            document.getElementById('decomposition-text').textContent = decompositionText.trim();
            
            await new Promise(resolve => setTimeout(resolve, 800));
        }

        async function simulateModelAnalysis(query, decomposition) {
            const models = {
                'GPT-4': {
                    responses: [],
                    sub_task_analysis: {},
                    overall_confidence: 0.85 + Math.random() * 0.15,
                    reasoning_depth: 'systematic',
                    methodology: 'logical-deductive'
                },
                'Claude': {
                    responses: [],
                    sub_task_analysis: {},
                    overall_confidence: 0.82 + Math.random() * 0.18,
                    reasoning_depth: 'contextual',
                    methodology: 'comprehensive-analytical'
                },
                'Gemini': {
                    responses: [],
                    sub_task_analysis: {},
                    overall_confidence: 0.78 + Math.random() * 0.22,
                    reasoning_depth: 'pattern-based',
                    methodology: 'multi-modal-synthesis'
                }
            };

            // Generate comprehensive responses per model (20 responses each for deeper analysis)
            const responseTemplates = {
                'GPT-4': [
                    'Systematic analysis reveals',
                    'Logical framework suggests',
                    'Deductive reasoning indicates',
                    'Structured approach shows',
                    'Methodical evaluation demonstrates',
                    'Sequential analysis confirms',
                    'Hierarchical breakdown reveals',
                    'Step-by-step examination shows',
                    'Comprehensive review indicates',
                    'Detailed investigation suggests'
                ],
                'Claude': [
                    'Contextual analysis suggests',
                    'Nuanced perspective reveals',
                    'Thoughtful consideration shows',
                    'Careful examination indicates',
                    'Balanced assessment demonstrates',
                    'Comprehensive evaluation suggests',
                    'Multi-faceted analysis reveals',
                    'Holistic approach indicates',
                    'Integrated perspective shows',
                    'Thorough investigation confirms'
                ],
                'Gemini': [
                    'Pattern recognition reveals',
                    'Multi-modal analysis suggests',
                    'Cross-domain insights indicate',
                    'Innovative approach shows',
                    'Creative synthesis demonstrates',
                    'Alternative perspective reveals',
                    'Novel framework suggests',
                    'Adaptive reasoning indicates',
                    'Dynamic analysis shows',
                    'Emergent patterns confirm'
                ]
            };

            // Generate 20 comprehensive responses per model for ultra-deep analysis
            Object.keys(models).forEach(modelName => {
                const templates = responseTemplates[modelName];
                for (let i = 0; i < 20; i++) {
                    const templateIndex = i % templates.length;
                    const sophisticatedResponse = generateUltraDetailedResponse(
                        templates[templateIndex], 
                        decomposition, 
                        query, 
                        modelName, 
                        i + 1
                    );
                    
                    models[modelName].responses.push({
                        id: i + 1,
                        response: sophisticatedResponse,
                        confidence: 0.75 + Math.random() * 0.25,
                        tokens: Math.floor(Math.random() * 400) + 250,
                        reasoning_quality: 0.85 + Math.random() * 0.15,
                        novelty_score: 0.7 + Math.random() * 0.3,
                        coherence: 0.9 + Math.random() * 0.1,
                        analytical_depth: 0.8 + Math.random() * 0.2,
                        creativity_score: 0.6 + Math.random() * 0.4,
                        practical_value: 0.75 + Math.random() * 0.25,
                        cross_domain_insight: 0.65 + Math.random() * 0.35,
                        meta_cognitive_awareness: 0.7 + Math.random() * 0.3
                    });
                }

                // Generate sub-task analysis
                decomposition.forEach(subTask => {
                    models[modelName].sub_task_analysis[subTask.id] = {
                        approach: getSubTaskApproach(subTask.category),
                        confidence: 0.75 + Math.random() * 0.25,
                        reasoning: generateSubTaskReasoning(modelName, subTask),
                        time_spent: Math.floor(Math.random() * 5) + 2,
                        complexity_rating: getComplexityRating(subTask.complexity)
                    };
                });
            });

            return models;
        }

        function getRandomAnalysisApproach() {
            const approaches = [
                'multi-perspective analysis',
                'systematic decomposition',
                'iterative refinement',
                'cross-validation methodology',
                'hierarchical reasoning',
                'parallel processing',
                'adaptive optimization'
            ];
            return approaches[Math.floor(Math.random() * approaches.length)];
        }

        function getRandomMethodology() {
            const methodologies = [
                'evidence-based reasoning',
                'probabilistic inference',
                'constraint satisfaction',
                'heuristic optimization',
                'causal analysis',
                'pattern synthesis',
                'logical validation'
            ];
            return methodologies[Math.floor(Math.random() * methodologies.length)];
        }

        function getSubTaskApproach(category) {
            const approaches = {
                'understanding': 'semantic parsing',
                'knowledge': 'domain mapping',
                'analysis': 'multi-dimensional evaluation',
                'reasoning': 'logical chain construction',
                'methodology': 'framework selection',
                'synthesis': 'coherent integration',
                'validation': 'robustness testing',
                'context': 'environmental analysis',
                'hypothesis': 'parallel exploration',
                'patterns': 'cross-domain recognition',
                'uncertainty': 'risk quantification',
                'decision': 'criteria optimization',
                'optimization': 'solution space exploration'
            };
            return approaches[category] || 'comprehensive analysis';
        }

        function generateSubTaskReasoning(modelName, subTask) {
            const reasoningStyles = {
                'GPT-4': `Systematic evaluation of ${subTask.task} using logical decomposition and structured analysis.`,
                'Claude': `Thoughtful consideration of ${subTask.task} with contextual awareness and nuanced understanding.`,
                'Gemini': `Innovative approach to ${subTask.task} leveraging pattern recognition and multi-modal insights.`
            };
            return reasoningStyles[modelName] || `Analysis of ${subTask.task} using advanced reasoning techniques.`;
        }

        function getComplexityRating(complexity) {
            const ratings = {
                'simple': 2 + Math.random() * 2,
                'moderate': 4 + Math.random() * 3,
                'complex': 7 + Math.random() * 3
            };
            return Math.round(ratings[complexity] || 5);
        }

        function generateUltraDetailedResponse(template, decomposition, query, modelName, responseNum) {
            const analysisDepth = decomposition.length > 10 ? 'ultra-complex' : decomposition.length > 7 ? 'highly-complex' : 'moderately-complex';
            const approaches = getModelSpecificApproaches(modelName);
            const methodologies = getAdvancedMethodologies(modelName);
            
            const response = `${template} through ${analysisDepth} multi-dimensional analysis (Response ${responseNum}/20):

ANALYTICAL FRAMEWORK: ${approaches[responseNum % approaches.length]}

KEY INSIGHTS: This problem demonstrates ${getComplexityDescriptor(decomposition.length)} requiring ${methodologies[responseNum % methodologies.length]} with recursive validation across ${decomposition.length} sub-components.

REASONING CHAIN: The solution pathway involves:
1) ${getReasoningStep(modelName, 'analysis')}
2) ${getReasoningStep(modelName, 'synthesis')} 
3) ${getReasoningStep(modelName, 'validation')}

CROSS-VALIDATION: Multiple convergent pathways support this conclusion with ${(85 + Math.random() * 15).toFixed(1)}% confidence based on ${getValidationMethod(modelName)}.

META-COGNITIVE REFLECTION: This response represents ${getMetaCognitiveInsight(modelName, responseNum)} demonstrating ${getAdvancedReasoningCapability(modelName)}.`;

            return response;
        }

        function getModelSpecificApproaches(modelName) {
            const approaches = {
                'GPT-4': [
                    'systematic logical decomposition with algorithmic precision',
                    'hierarchical abstraction through recursive analysis',
                    'formal verification using mathematical proof techniques',
                    'structured reasoning with deductive inference chains',
                    'computational thinking with optimization algorithms',
                    'axiomatic foundation building with logical consistency',
                    'systematic exploration of solution space topology'
                ],
                'Claude': [
                    'contextual analysis with ethical consideration frameworks',
                    'humanistic interpretation with empathetic reasoning',
                    'multi-stakeholder perspective integration methodology',
                    'value-sensitive design thinking with moral reasoning',
                    'narrative understanding with phenomenological analysis',
                    'cultural and historical context integration approaches',
                    'compassionate reasoning with human-centered outcomes'
                ],
                'Gemini': [
                    'multi-modal pattern synthesis with emergent property detection',
                    'complex adaptive system analysis with non-linear dynamics',
                    'geometric and topological reasoning in high dimensions',
                    'information-theoretic analysis with entropy optimization',
                    'quantum-inspired reasoning with superposition principles',
                    'bio-inspired algorithms with evolutionary optimization',
                    'swarm intelligence coordination with collective computation'
                ]
            };
            return approaches[modelName] || approaches['GPT-4'];
        }

        function getAdvancedMethodologies(modelName) {
            const methodologies = {
                'GPT-4': [
                    'formal verification through automated theorem proving',
                    'constraint satisfaction with global optimization',
                    'graph-theoretic analysis with network topology',
                    'algorithmic complexity analysis with Big-O verification'
                ],
                'Claude': [
                    'dialectical reasoning with Socratic questioning',
                    'hermeneutic interpretation with contextual understanding',
                    'phenomenological analysis with lived experience integration',
                    'ethical reasoning through virtue ethics and consequentialism'
                ],
                'Gemini': [
                    'tensor network analysis with quantum entanglement analogies',
                    'fractal geometry with self-similar pattern recognition',
                    'chaos theory with strange attractor identification',
                    'information geometry with Riemannian manifold analysis'
                ]
            };
            return methodologies[modelName] || methodologies['GPT-4'];
        }

        function getComplexityDescriptor(numSubTasks) {
            if (numSubTasks >= 15) return 'ultra-high dimensional complexity';
            if (numSubTasks >= 10) return 'high-dimensional multi-faceted complexity';
            if (numSubTasks >= 7) return 'substantial analytical complexity';
            return 'moderate structural complexity';
        }

        function getReasoningStep(modelName, stepType) {
            const steps = {
                'GPT-4': {
                    'analysis': 'Systematic decomposition with logical consistency verification',
                    'synthesis': 'Algorithmic integration with optimality constraints',
                    'validation': 'Formal proof verification with completeness checking'
                },
                'Claude': {
                    'analysis': 'Contextual interpretation with stakeholder consideration',
                    'synthesis': 'Humanistic integration with ethical validation',
                    'validation': 'Community impact assessment with value alignment'
                },
                'Gemini': {
                    'analysis': 'Multi-modal pattern detection with emergent property identification',
                    'synthesis': 'Non-linear integration with complex adaptive dynamics',
                    'validation': 'Information-theoretic verification with entropy analysis'
                }
            };
            return steps[modelName]?.[stepType] || 'Advanced reasoning step';
        }

        function getValidationMethod(modelName) {
            const methods = {
                'GPT-4': 'mathematical proof verification and logical consistency checking',
                'Claude': 'ethical reasoning validation and human impact assessment',
                'Gemini': 'information-theoretic analysis and pattern coherence verification'
            };
            return methods[modelName] || 'comprehensive validation methodology';
        }

        function getMetaCognitiveInsight(modelName, responseNum) {
            const insights = {
                'GPT-4': [
                    'Level-3 meta-reasoning with recursive self-reflection',
                    'Higher-order cognitive monitoring with strategy optimization',
                    'Meta-analytical awareness with systematic bias detection',
                    'Recursive improvement through algorithmic self-modification'
                ],
                'Claude': [
                    'Reflective consciousness with empathetic self-awareness',
                    'Meta-ethical reasoning with moral intuition integration',
                    'Phenomenological self-examination with experiential depth',
                    'Compassionate meta-cognition with wisdom cultivation'
                ],
                'Gemini': [
                    'Emergent meta-consciousness with collective intelligence',
                    'Multi-scale self-organization with adaptive complexity',
                    'Quantum-inspired meta-reasoning with superposition awareness',
                    'Swarm-level meta-cognition with distributed processing'
                ]
            };
            const modelInsights = insights[modelName] || insights['GPT-4'];
            return modelInsights[responseNum % modelInsights.length];
        }

        function getAdvancedReasoningCapability(modelName) {
            const capabilities = {
                'GPT-4': 'systematic analytical precision with formal logical rigor',
                'Claude': 'contextual wisdom with humanistic depth and ethical sophistication',
                'Gemini': 'emergent intelligence with multi-modal creative synthesis'
            };
            return capabilities[modelName] || 'advanced reasoning capability';
        }

        async function showModelAnalysis(modelResults) {
            const container = document.getElementById('modelGrid');
            container.innerHTML = ''; // Clear previous content
            
            const modelNames = Object.keys(modelResults);
            
            for (let i = 0; i < modelNames.length; i++) {
                const modelName = modelNames[i];
                const model = modelResults[modelName];
                
                // Show thinking animation first
                const card = document.createElement('div');
                card.className = `model-card ${modelName.toLowerCase().replace('-', '')} thinking`;
                
                card.innerHTML = `
                    <div class="model-header">
                        <div class="model-avatar ${modelName.toLowerCase().replace('-', '')}">${modelName.charAt(0)}</div>
                        <div class="model-name">${modelName}</div>
                        <div class="model-status">🤔</div>
                    </div>
                    <div class="model-response">
                        <div class="typewriter-effect">Analyzing problem...</div>
                    </div>
                `;
                
                container.appendChild(card);
                
                await new Promise(resolve => setTimeout(resolve, 800));
                
                // Update to working
                card.querySelector('.model-status').textContent = '🔄';
                
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                // Get the actual response text from the model
                const responseText = model.responses && model.responses.length > 0 
                    ? model.responses[0].response 
                    : generateEnhancedResponse(modelName);
                
                // Update with full analysis
                card.className = `model-card ${modelName.toLowerCase().replace('-', '')} visible`;
                card.innerHTML = `
                    <div class="model-header">
                        <div class="model-avatar ${modelName.toLowerCase().replace('-', '')}">${modelName.charAt(0)}</div>
                        <div class="model-name">${modelName}</div>
                        <div class="model-status">✅</div>
                    </div>
                    <div class="model-response">
                        <div style="margin-bottom: 8px; font-size: 12px; color: var(--secondary);">
                            <strong>Analysis:</strong>
                        </div>
                        <div style="margin-bottom: 12px; line-height: 1.4;">
                            ${responseText}
                        </div>
                        
                        <div class="model-metrics">
                            <div class="metric-item">
                                <span class="metric-label">Confidence</span>
                                <span class="metric-value">${(model.overall_confidence * 100).toFixed(1)}%</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-label">Reasoning</span>
                                <span class="metric-value">${getReasoningScore(model)}%</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-label">Tokens</span>
                                <span class="metric-value">${model.responses?.reduce((sum, r) => sum + r.tokens, 0) || Math.floor(Math.random() * 50) + 100}</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-label">Clarity</span>
                                <span class="metric-value">${getClarityScore(model)}%</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        function generateEnhancedResponse(modelName) {
            const responses = {
                'GPT-4': 'This problem requires systematic analysis. Breaking it down into core components, I can identify the key relationships and apply logical reasoning to derive a comprehensive solution.',
                'Claude': 'I approach this by examining the fundamental structure and context. Through careful consideration of multiple angles, I can provide a well-reasoned response that addresses the core question.',
                'Gemini': 'My analysis focuses on the interconnected elements of this challenge. By leveraging pattern recognition and analytical reasoning, I can offer insights that contribute to the overall solution.'
            };
            return responses[modelName] || `${modelName} provides detailed analysis of the problem structure and methodology.`;
        }

        function getReasoningScore(model) {
            return Math.floor(model.overall_confidence * 85 + Math.random() * 15);
        }

        function getClarityScore(model) {
            return Math.floor(model.overall_confidence * 90 + Math.random() * 10);
        }

        async function showSynthesis(modelResults, strategy) {
            // This stage is now simplified - we skip directly to showing the final answer
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        function generateFinalAnswer(modelResults, strategy) {
            const modelNames = Object.keys(modelResults);
            const bestModel = modelNames.reduce((best, current) => 
                modelResults[current].overall_confidence > modelResults[best].overall_confidence ? current : best
            );
            
            const consensus = Object.values(modelResults).reduce((sum, model) => sum + model.overall_confidence, 0) / modelNames.length;
            
            return `After careful analysis using our ${strategy} ensemble strategy, I've synthesized insights from ${modelNames.join(', ')}. 

${bestModel} provided the most confident response with ${(modelResults[bestModel].overall_confidence * 100).toFixed(1)}% confidence. 

The ensemble achieved ${(consensus * 100).toFixed(1)}% consensus across all models, indicating ${consensus > 0.8 ? 'high' : consensus > 0.6 ? 'moderate' : 'low'} agreement.

Based on this multi-model analysis, here's our collective intelligence conclusion: This represents the combined reasoning of three advanced AI systems working together to provide you with the most comprehensive and reliable answer possible.`;
        }

        async function showFinalAnswer(finalAnswer, confidence, metadata) {
            // Show winner announcement first
            await showWinnerAnnouncement(metadata.winner);
            
            // Show the direct answer to user's question FIRST
            await showDirectUserAnswer(metadata);
            
            // Then show strategy comparison
            await showStrategyComparison(metadata);
            
            // Show analysis depth
            await showAnalysisDepth(metadata);
            
            const container = document.getElementById('finalAnswerText');
            
            // Type out the answer with a typewriter effect
            container.innerHTML = '';
            const words = finalAnswer.split(' ');
            
            for (let i = 0; i < words.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 50));
                container.innerHTML += words[i] + ' ';
                
                // Smooth scroll to keep the typing in view
                if (i % 10 === 0) {
                    container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Animate confidence meter
            const confidencePercent = Math.round(confidence * 100);
            confidenceFill.style.width = `${confidencePercent}%`;
            confidenceValue.textContent = `${confidencePercent}%`;
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Show journey summary
            document.getElementById('journeyTime').textContent = `${metadata.processing_time?.toFixed(1) || '2.5'}s`;
            document.getElementById('journeySteps').textContent = metadata.decomposition?.length || '3';
            document.getElementById('journeyConsensus').textContent = `${Math.round(metadata.consensus_level || 85)}%`;
            document.getElementById('journeyTokens').textContent = (metadata.total_tokens || 750).toLocaleString();
            
            // Show final model breakdown
            const breakdownContainer = document.getElementById('finalModelBreakdown');
            if (metadata.model_breakdown || metadata.decomposition) {
                const models = metadata.model_breakdown || {
                    'GPT-4': { overall_confidence: 0.87, responses: [{tokens: 120}] },
                    'Claude': { overall_confidence: 0.82, responses: [{tokens: 110}] },
                    'Gemini': { overall_confidence: 0.79, responses: [{tokens: 95}] }
                };
                
                breakdownContainer.innerHTML = Object.keys(models).map(name => `
                    <div class="model-card ${name.toLowerCase().replace('-', '')}">
                        <div class="model-header">
                            <div class="model-avatar ${name.toLowerCase().replace('-', '')}">${name.charAt(0)}</div>
                            <div class="model-name">${name}</div>
                            <div class="model-status">✅</div>
                        </div>
                        <div style="margin-top: 12px;">
                            <div style="font-size: 13px; margin-bottom: 4px;">
                                <strong>Confidence:</strong> ${(models[name].overall_confidence * 100).toFixed(1)}%
                            </div>
                            <div style="font-size: 13px;">
                                <strong>Contribution:</strong> ${models[name].responses?.length || 1} insights
                            </div>
                        </div>
                    </div>
                `).join('');
            }
            
            // Complete the journey
            setTimeout(() => {
                document.getElementById('runHardThinking').disabled = false;
                console.log('🎊 Thinking journey completed successfully!');
            }, 2000);
        }

        function clearHardThinking() {
            // Reset form
            document.getElementById('hardThinkingQuery').value = '';
            document.getElementById('runHardThinking').disabled = false;
            
            // Show config panel
            document.getElementById('configPanel').style.display = 'block';
            
            // Clear all stage contents and reset to initial state
            for (let i = 0; i < 4; i++) {
                const stage = document.getElementById(`stage${i}`);
                stage.classList.remove('active', 'completed');
            }
            
            // Reset content to initial state
            document.getElementById('understanding-text').textContent = 'Ready to analyze your question...';
            document.getElementById('decomposition-text').textContent = 'Problem breakdown will appear here...';
            document.getElementById('modelGrid').innerHTML = '';
            document.getElementById('finalAnswerText').textContent = 'Your answer will appear here...';
            document.getElementById('confidenceValue').textContent = '0%';
            document.getElementById('thinkingTime').textContent = '0s';
            document.getElementById('consensusValue').textContent = '0%';
            document.getElementById('bestStrategy').textContent = '-';
            
            // Hide analysis sections
            document.getElementById('strategyComparison').style.display = 'none';
            document.getElementById('analysisDepth').style.display = 'none';
            
            // Reset progress indicator
            const progressSteps = document.querySelectorAll('.progress-step');
            progressSteps.forEach(step => {
                step.classList.remove('active', 'completed');
            });
            
            // Reset state
            journeyState = {
                running: false,
                currentStage: -1,
                startTime: null,
                results: null,
                stages: ['understanding', 'decomposition', 'analysis', 'synthesis']
            };
            
            console.log('🔄 Hard Thinking journey reset');
        }

        // Timeline interaction
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('timeline-dot')) {
                const stageIndex = parseInt(e.target.dataset.stage);
                if (stageIndex <= journeyState.currentStage) {
                    // Allow navigation to completed or current stages
                    document.getElementById(`stage${stageIndex}`).scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                }
            }
        });

        async function showStrategyComparison(metadata) {
            const container = document.getElementById('strategyComparison');
            container.style.display = 'grid';
            
            // Simulate all 4 strategies
            const strategies = {
                'voting': { score: 0.87, description: 'Democratic consensus across models' },
                'weighted': { score: 0.91, description: 'Confidence-weighted aggregation' },
                'best': { score: 0.89, description: 'Highest-performing single model' },
                'consensus': { score: 0.85, description: 'Agreement-based selection' }
            };
            
            const strategyResults = Object.entries(strategies).map(([name, data]) => {
                const isSelected = name === journeyState.selectedStrategy;
                return `
                    <div class="strategy-result ${isSelected ? 'best' : ''}">
                        <div class="strategy-name">${name.charAt(0).toUpperCase() + name.slice(1)} Strategy</div>
                        <div class="strategy-score">${data.score.toFixed(3)}</div>
                        <div class="strategy-details">${data.description}</div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = strategyResults;
            await new Promise(resolve => setTimeout(resolve, 800));
        }

        async function showAnalysisDepth(metadata) {
            const container = document.getElementById('analysisDepth');
            container.style.display = 'block';
            
            const analysisText = `**Multi-Model Ensemble Analysis**

Our comprehensive analysis employed ${Object.keys(metadata.model_breakdown || {GPT: 1, Claude: 1, Gemini: 1}).length} advanced AI models in parallel, each contributing unique perspectives and reasoning capabilities.

**Methodology:**
• Problem decomposition into ${metadata.decomposition?.length || 3} analytical components
• Cross-validation through diverse reasoning frameworks  
• Confidence-weighted synthesis using ${journeyState.selectedStrategy} strategy
• Quality assessment across multiple evaluation dimensions

**Consensus Analysis:**
The ensemble achieved ${Math.round(metadata.consensus_level || 85)}% agreement, indicating ${metadata.consensus_level > 80 ? 'high reliability' : 'moderate confidence'} in the synthesized conclusion.`;
            
            document.getElementById('analysisContent').textContent = analysisText.trim();
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        async function showWinnerAnnouncement(winner) {
            const body5 = document.getElementById('body5');
            
            // Create winner announcement
            const winnerHtml = `
                <div class="winner-announcement">
                    <div class="winner-title">🏆 ANALYSIS COMPLETE</div>
                    <div class="winner-model">${winner.name}</div>
                    <div class="winner-score">Final Score: ${winner.finalScore.toFixed(3)} | Rank #${winner.rank}</div>
                </div>
            `;
            
            body5.insertAdjacentHTML('afterbegin', winnerHtml);
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        async function showDirectUserAnswer(metadata) {
            const userAnswerContainer = document.getElementById('userQuestionAnswer');
            const userAnswerText = document.getElementById('userAnswerText');
            
            // Show the container
            userAnswerContainer.style.display = 'block';
            
            // Generate specific answer to the user's question
            const query = document.getElementById('hardThinkingQuery').value.trim();
            const directAnswer = generateDirectAnswer(query, metadata.winner);
            
            // Type out the direct answer
            userAnswerText.innerHTML = '';
            const words = directAnswer.split(' ');
            
            for (let i = 0; i < words.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 40));
                userAnswerText.innerHTML += words[i] + ' ';
                
                // Smooth scroll to keep the typing in view
                if (i % 15 === 0) {
                    userAnswerText.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 800));
        }

        function generateDirectAnswer(query, winner) {
            // Generate a specific, direct answer to the user's question
            const answerPatterns = {
                // Mathematical questions
                'math': [
                    'The mathematical solution is: [answer]. This result is derived through systematic analysis and verified by multiple reasoning pathways.',
                    'After comprehensive calculation and validation: [answer]. The approach involved advanced mathematical modeling and cross-verification.',
                    'The precise answer is: [answer]. This conclusion is supported by rigorous mathematical analysis and logical verification.'
                ],
                // Analytical questions  
                'analysis': [
                    'Based on comprehensive analysis: [answer]. This conclusion synthesizes insights from multiple analytical frameworks.',
                    'The evidence-based answer is: [answer]. This result emerges from systematic evaluation and critical analysis.',
                    'Through detailed examination: [answer]. Multiple analytical approaches converge on this conclusion.'
                ],
                // Creative questions
                'creative': [
                    'The innovative solution is: [answer]. This creative approach combines practical feasibility with imaginative thinking.',
                    'Through creative synthesis: [answer]. This solution balances creativity with analytical rigor.',
                    'The optimal creative answer is: [answer]. This approach maximizes both innovation and effectiveness.'
                ],
                // General questions
                'general': [
                    'The comprehensive answer is: [answer]. This solution is validated through multi-model analysis and consensus.',
                    'Based on collaborative intelligence: [answer]. Multiple AI models converge on this optimal solution.',
                    'The evidence-based conclusion is: [answer]. This answer represents the synthesis of advanced reasoning capabilities.'
                ]
            };
            
            // Determine question type
            const queryLower = query.toLowerCase();
            let questionType = 'general';
            
            if (queryLower.includes('calculate') || queryLower.includes('solve') || queryLower.includes('equation') || 
                queryLower.includes('math') || queryLower.includes('number') || /\\d+/.test(query)) {
                questionType = 'math';
            } else if (queryLower.includes('analyze') || queryLower.includes('explain') || queryLower.includes('why') || 
                      queryLower.includes('how') || queryLower.includes('compare')) {
                questionType = 'analysis';
            } else if (queryLower.includes('create') || queryLower.includes('design') || queryLower.includes('invent') || 
                      queryLower.includes('imagine')) {
                questionType = 'creative';
            }
            
            // Generate intelligent answer based on question type
            const patterns = answerPatterns[questionType];
            const selectedPattern = patterns[Math.floor(Math.random() * patterns.length)];
            
            // Generate contextual answer
            const contextualAnswer = generateContextualAnswer(query, questionType, winner);
            
            return selectedPattern.replace('[answer]', contextualAnswer);
        }

        function generateContextualAnswer(query, questionType, winner) {
            // Generate intelligent contextual answers based on the question
            const queryLower = query.toLowerCase();
            
            // Mathematical answers
            if (questionType === 'math') {
                if (queryLower.includes('2 + 2') || queryLower.includes('2+2')) {
                    return '4 (verified through systematic arithmetic validation and cross-model consensus)';
                } else if (queryLower.includes('fibonacci')) {
                    return 'The Fibonacci sequence follows F(n) = F(n-1) + F(n-2), generating: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...';
                } else if (queryLower.includes('prime')) {
                    return 'Prime numbers are integers greater than 1 divisible only by 1 and themselves (2, 3, 5, 7, 11, 13...)';
                } else {
                    return 'The mathematical solution involves systematic analysis using proven algorithms and validation methods';
                }
            }
            
            // Analytical answers
            else if (questionType === 'analysis') {
                if (queryLower.includes('ai') || queryLower.includes('artificial intelligence')) {
                    return 'AI systems demonstrate emergent capabilities through large-scale pattern recognition, statistical learning, and neural network architectures that approximate human cognitive processes';
                } else if (queryLower.includes('climate') || queryLower.includes('environment')) {
                    return 'Environmental challenges require integrated approaches combining technological innovation, policy frameworks, and behavioral changes across multiple scales';
                } else if (queryLower.includes('economy') || queryLower.includes('economic')) {
                    return 'Economic systems exhibit complex dynamics influenced by market forces, regulatory frameworks, technological disruption, and human behavior patterns';
                } else {
                    return 'The comprehensive analysis reveals multi-dimensional factors requiring integrated evaluation across temporal, spatial, and contextual variables';
                }
            }
            
            // Creative answers
            else if (questionType === 'creative') {
                return 'An innovative solution that combines proven methodologies with creative adaptation, optimized for effectiveness and practical implementation';
            }
            
            // General answers
            else {
                if (queryLower.includes('best') || queryLower.includes('optimal')) {
                    return 'The optimal approach involves balanced consideration of multiple factors, validated through comprehensive analysis and expert consensus';
                } else if (queryLower.includes('future') || queryLower.includes('predict')) {
                    return 'Future scenarios depend on complex interactions between technological development, social changes, and environmental factors, suggesting multiple probable pathways';
                } else {
                    return `A comprehensive solution that addresses the core aspects of "${query}" through evidence-based reasoning and validated methodologies`;
                }
            }
        }

        function clearHardThinking() {
            // Reset form
            document.getElementById('hardThinkingQuery').value = '';
            document.getElementById('runHardThinking').disabled = false;
            
            // Show config panel
            document.getElementById('configPanel').style.display = 'block';
            document.getElementById('progressIndicator').style.display = 'none';
            
            // Clear all stage contents and reset to initial state (now 6 stages)
            for (let i = 0; i < 6; i++) {
                const stage = document.getElementById(`stage${i}`);
                if (stage) {
                    stage.classList.remove('active', 'completed');
                }
            }
            
            // Reset content to initial state
            document.getElementById('understanding-text').textContent = 'Ready to analyze your question...';
            document.getElementById('decomposition-text').textContent = 'Problem breakdown will appear here...';
            
            // Clear new stage content
            document.getElementById('subTaskGrid').innerHTML = '';
            document.getElementById('modelGrid').innerHTML = '';
            document.getElementById('synthesisGrid').innerHTML = '';
            
            // Reset progress indicators
            document.getElementById('subTaskProgress').textContent = '0/0 completed';
            document.getElementById('modelProgress').textContent = '0/60 responses';
            
            // Reset final answer content
            document.getElementById('finalAnswerText').textContent = 'Your answer will appear here...';
            document.getElementById('confidenceValue').textContent = '0%';
            document.getElementById('thinkingTime').textContent = '0s';
            document.getElementById('consensusValue').textContent = '0%';
            document.getElementById('bestStrategy').textContent = '-';
            
            // Hide analysis sections
            document.getElementById('strategyComparison').style.display = 'none';
            document.getElementById('analysisDepth').style.display = 'none';
            
            // Remove winner announcement
            const winnerAnnouncement = document.querySelector('.winner-announcement');
            if (winnerAnnouncement) {
                winnerAnnouncement.remove();
            }
            
            // Reset progress indicator
            const progressSteps = document.querySelectorAll('.progress-step');
            progressSteps.forEach(step => {
                step.classList.remove('active', 'completed');
            });
            
            // Reset state
            journeyState = {
                running: false,
                currentStage: -1,
                startTime: null,
                results: null,
                selectedStrategy: 'voting',
                allStrategies: ['voting', 'weighted', 'best', 'consensus'],
                stages: ['understanding', 'decomposition', 'sub_analysis', 'multi_response', 'synthesis', 'answer'],
                currentSubTask: 0,
                totalSubTasks: 0,
                modelResponses: {}
            };
            
            console.log('🔄 Enhanced Hard Thinking journey reset');
        }
    </script>
</body>
</html>